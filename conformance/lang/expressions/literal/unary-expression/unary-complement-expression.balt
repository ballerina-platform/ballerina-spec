Test-Case: output
Description: Test unary complement integer basic operations.
Labels: additive-expr, unary-complement, unary-minus

public function main() {
    io:println(~0); // @output -1

    int a1 = ~1;
    io:println(a1); // @output -2

    io:println(~-1); // @output 0

    io:println(~0 is int); // @output true

    io:println(~~0 == 0); // @output true

    io:println(~5 == -(5 + 1)); // @output true
}

Test-Case: output
Description: Test unary complement integer operations at module level.
Labels: const, unary-complement

int complementOfZero = ~0;
var complementOfOne = ~1;

const int CONST1 = ~2;
const int CONST2 = ~CONST1;
const int CONST3 = ~(-36);

public function main() {
    io:println(complementOfZero); // @output -1

    io:println(complementOfOne is int); // @output true

    io:println(CONST1); // @output -3

    io:println(CONST2); // @output 2

    io:println(CONST3); // @output 35
}

Test-Case: output
Description: Test unary complement expressions with int sub types.
Labels: const, function-defn, langlib, unary-complement

int:Unsigned8 unsignedInt = 0;

const byte CONST1 = 0;

public function main() {
    byte a1 = 0;
    io:println(getComplement(a1)); // @output -1

    io:println(getComplement(unsignedInt)); // @output -1

    io:println(getComplement(CONST1)); // @output -1

    int:Unsigned8 a2 = 0;
    io:println(getComplement(a2)); // @output -1

    int:Unsigned16 a3 = 0;
    io:println(getComplement(a3)); // @output -1
    io:println(getComplement(a3) is int:Signed16); // @output true

    int:Unsigned32 a4 = 0;
    io:println(getComplement(a4)); // @output -1

    int:Signed8 a5 = 0;
    io:println(getComplement(a5)); // @output -1

    int:Signed16 a6 = 0;
    io:println(getComplement(a6)); // @output -1

    int:Signed32 a7 = 0;
    io:println(getComplement(a7)); // @output -1

    io:println(getComplement(int:MAX_VALUE));  // @output -9223372036854775808
    io:println(getComplement(int:MIN_VALUE));  // @output 9223372036854775807

    io:println(getComplement(int:UNSIGNED8_MAX_VALUE));  // @output -256
    io:println(getComplement(int:UNSIGNED16_MAX_VALUE));  // @output -65536
    io:println(getComplement(int:UNSIGNED32_MAX_VALUE));  // @output -4294967296

    io:println(getComplement(int:SIGNED8_MIN_VALUE));  // @output 127
    io:println(getComplement(int:SIGNED8_MAX_VALUE));  // @output -128

    io:println(getComplement(int:SIGNED16_MIN_VALUE));  // @output 32767
    io:println(getComplement(int:SIGNED16_MAX_VALUE));  // @output -32768

    io:println(getComplement(int:SIGNED32_MIN_VALUE));  // @output 2147483648
    io:println(getComplement(int:SIGNED32_MAX_VALUE));  // @output -2147483648

    io:println((~0x7FFFFFFFFFFFFFFF).toHexString()); // @output 8000000000000000
}

public function getComplement(int i) returns int {
    return ~i;
}

Test-Case: error
Description: Test unary complement expression assignments resulting in an error.
Labels: byte, langlib, module-type-defn, unary-complement

type Ints -1|-2;

public function main() {
    byte x3 = 0;
    byte x4 = ~x3; // @error static type of complement expression with operand of int subtype is int

    int:Unsigned8 x5 = 0;
    int:Unsigned8 x6 = ~x5; // @error static type of complement expression with operand of int subtype is int

    Ints x7 = ~1; // @error static type of complement expression with operand of int subtype is int
}

Test-Case: error
Description: Test the static type of operand belonging to non-int type resulting in an error.
Fail-Issue: ballerina-lang#32628
Labels: const, function-defn, optional-type, multiplicative-expr, tuple-type, unary-complement

const int CONST1 = ~false; // @error unary complement not supported for boolean
const int CONST2 = ~~false; // @error unary complement not supported for boolean

public function main() {
    io:println(~true); // @error unary complement not supported for boolean

    int x7 = ~getIntOrNil(); // @error unary complement not supported for int?

    [int, int] intTuple = [1, 2];
    int x8 = ~intTuple; // @error unary complement not supported for [int, int]

    var x9 = 1.5 * 2.5;
    int x10 = ~x9; // @error unary complement not supported for float

    int x11 = ~~false; // @error unary complement not supported for boolean
}

function getIntOrNil() returns int? {
    return 0;
}

Test-Case: output
Description: Test unary complement operator with unary-plus and unary-minus operators.
Fail-Issue: ballerina-lang#32702
Labels: function-defn, unary-complement, unary-minus, unary-plus

public function main() {
    io:println(+~1); // @output -2
    io:println(~+1); // @output -2
    io:println(~-1); // @output 0
    io:println(-~1); // @output 2

    io:println(minusTwo(42)); // @output 40
    io:println(minusTwo(-98)); // @output -100

    io:println(addTwo(42)); // @output 44
    io:println(addTwo(-98)); // @output -96
}

public function minusTwo(int i) returns int {
    return ~-~-i;
}
public function addTwo(int i) returns int {
    return -~-~i;
}
