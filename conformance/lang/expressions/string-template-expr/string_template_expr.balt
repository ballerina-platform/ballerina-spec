Test-Case: output
Description: Test whether string template expression interpolates the results of evaluating expressions into a literal string.
Labels: additive-expr, int, string, string-literal, string-template-expr

function init() {
    string a1 = "a1";
    string temp1 = string `${a1}`;
    io:println(temp1); // @output a1
    int a2 = 12;
    string temp2 = string `${a2}`;
    io:println(temp2); // @output 12
    int a3 = 13;
    string temp3 = string `${a2 + a3}`;
    io:println(temp3); // @output 25
    string temp4 = string `${"a2"}`;
    io:println(temp4); // @output a2
}

Test-Case: error
Description: Test string template expression when expected type is not a string.
Labels: additive-expr, int, string, string-literal, string-template-expr

function errorFunction() {
    string a1 = "a1";
    int _ = string `${a1}`; // @error expected 'int' but found 'string'
    int a2 = 12;
    int _ = string `${a2}`; // @error expected 'int' but found 'string'
    int a3 = 13;
    int _ = string `${a2 + a3}`; // @error expected 'int' but found 'string'
}

Test-Case: output
Description: Test string template expression with basic type literals.
Labels: boolean, DecimalNumber, float, int, string, string-template-expr

function init() {
    string a1 = "a1";
    string temp1 = string `${a1}`;
    io:println(temp1); // @output a1
    int a2 = 12;
    string temp2 = string `${a2}`;
    io:println(temp2); // @output 12
    decimal a3 = 23.5d;
    string temp3 = string `${a3}`;
    io:println(temp3); // @output 23.5
    decimal a4 = 23.5;
    string temp4 = string `${a4}`;
    io:println(temp4); // @output 23.5
    float a5 = 23.5;
    string temp5 = string `${a5}`;
    io:println(temp5); // @output 23.5
    float a6 = 0x32.5;
    string temp6 = string `${a6}`;
    io:println(temp6); // @output 50.3125
    boolean a7 = true;
    string temp7 = string `${a7}`;
    io:println(temp7); // @output true
    string:Char a8 = "C";
    string temp8 = string `${a8}`;
    io:println(temp8); // @output C
}

Test-Case: output
Description: Test string template expression with union type literals.
Labels: decimal, float, int, string, string-template-expr, union-type

function init() {
    string|int a1 = "a1";
    string temp1 = string `${a1}`;
    io:println(temp1); // @output a1
    int|float|decimal a2 = 12;
    string temp2 = string `${a2}`;
    io:println(temp2); // @output 12
    string|int|decimal|float|boolean a3 = true;
    string temp3 = string `${a3}`;
    io:println(temp3); // @output true
    int|string:Char a4 = "C";
    string temp4 = string `${a4}`;
    io:println(temp4); // @output C
    int|float|decimal|byte a5 = 12;
    string temp5 = string `${a5}`;
    io:println(temp5); // @output 12
}

Test-Case: output
Description: Test string template expression with intersection type literals.
Labels: decimal, float, int, intersection-type, string, string-template-expr, union-type

function init() {
    int|float|decimal & readonly a1 = 12;
    string temp2 = string `${a1}`;
    io:println(temp2); // @output 12
    string|int|decimal|float|boolean & readonly a2 = true;
    string temp3 = string `${a2}`;
    io:println(temp3); // @output true
}

Test-Case: output
Description: Test string template expression with defined type literals.
Labels: module-type-defn, singleton-type, string, string-literal, string-template-expr, union-type

type T1 "c";
type T2 "m"|"n";
type T3 2;
type T4 2.0|3|5;
type T5 true;

function init() {
    T1 a1 = "c";
    string temp1 = string `${a1}`;
    io:println(temp1); // @output c
    T2 a2 = "m";
    string temp2 = string `${a2}`;
    io:println(temp2); // @output m
    T3 a3 = 2;
    string temp3 = string `${a3}`;
    io:println(temp3); // @output 2
    T4 a4 = 5;
    string temp4 = string `${a4}`;
    io:println(temp4); // @output 5
    T5 a5 = true;
    string temp5 = string `${a5}`;
    io:println(temp5); // @output true
}

Test-Case: output
Description: Test string template expression with sub types of basic type literals.
Labels: byte, check, int, string, string-template-expr, union-type

function init() {
    byte a1 = 4;
    string temp1 = string `${a1}`;
    io:println(temp1); // @output 4
    int:Unsigned8 a2 = 12;
    string temp2 = string `${a2}`;
    io:println(temp2); // @output 12
    int:Signed8 a3 = 12;
    string temp3 = string `${a3}`;
    io:println(temp3); // @output 12
    int:Signed16 a4 = 23;
    string temp4 = string `${a4}`;
    io:println(temp4); // @output 23
    int:Unsigned16 a5 = 43;
    string temp5 = string `${a5}`;
    io:println(temp5); // @output 43
    int:Signed32 a6 = 0x33;
    string temp6 = string `${a6}`;
    io:println(temp6); // @output 51
    int:Unsigned32 a7 = 32;
    string temp7 = string `${a7}`;
    io:println(temp7); // @output 32
    byte|int:Unsigned8|int:Signed8|int:Unsigned16|int:Signed16|int:Unsigned32 a8 = 23;
    string temp8 = string `${a8}`;
    io:println(temp8); // @output 23
}

Test-Case: error
Description: Test string template expression with structured and behaviour type literals.
Labels: function-type, int, optional-type, record-type, string, string-template-expr, tuple-type

function errorFunction() {
    record {} a1 = {};
    string _ = string `${a1}`; // @error expected '(int|float|decimal|string|boolean)', found 'record {| anydata...; |}'
    function  a2 = f1;
    string _ = string `${a2}`; // @error expected '(int|float|decimal|string|boolean)', found 'function'
    () a3 = ();
    string _ = string `${a3}`; // @error expected '(int|float|decimal|string|boolean)', found '()'
    string? a4 = "a4";
    string _ = string `${a4}`; // @error expected '(int|float|decimal|string|boolean)', found 'string?'
    json a5 = 12;
    string _ = string `${a5}`; // @error expected '(int|float|decimal|string|boolean)', found 'json'
    [int, int] a6 = [10, 10];
    string _ = string `${a6}`; // @error expected '(int|float|decimal|string|boolean)', found '[int,int]'
}

function f1() returns int {
    return 10;
}

Test-Case: error
Description: Test string template expression with singleton type literals.
Labels: array-type, int, map-type, module-type-defn, singleton-type, string, string-template-expr, union-type

type T1 "C"|"S"|map<int>;
type T2 true|record {};
type T3 2|3|int[];

function errorFunction() {
    T1 a1 = "C";
    string _ = string `${a1}`; // @error expected '(int|float|decimal|string|boolean)', found 'T1'
    T2  a2 = true;
    string _ = string `${a2}`; // @error expected '(int|float|decimal|string|boolean)', found 'T2'
    T3 a3 = 2;
    string _ = string `${a3}`; // @error expected '(int|float|decimal|string|boolean)', found 'T3'
}

Test-Case: output
Description:  Test every character that is not part of an interpolation is interpreted as a literal character.
Labels: int, string, string-template-expr

function init() {
    string a1 = "a1";
    string temp1 = string `b1 ${a1}`;
    io:println(temp1); // @output b1 a1
    int a2 = 12;
    string temp2 = string `v1 ${a2} v2`;
    io:println(temp2); // @output v1 12 v2
    int a3 = 13;
    string temp3 = string `$ $ $ ${a2 + a3} $ $ $`;
    io:println(temp3); // @output $ $ $ 25 $ $ $
    string temp4 = string `$$${"a2"}$$`;
    io:println(temp4); // @output $$a2$$
    string temp5 = string `$v1$${"a2"}$v2$`;
    io:println(temp5); // @output $v1$a2$v2$
}

Test-Case: output
Description:  Test every character that is not part of an interpolation is interpreted as a literal character.
Labels: string, string-template-expr

function init() {
    string temp1 = string `b1`;
    io:println(temp1); // @output b1
    string temp2 = string `v1 v2`;
    io:println(temp2); // @output v1 v2
    string temp3 = string `$ $ $ $ $ $`;
    io:println(temp3); // @output $ $ $ $ $ $
    string temp4 = string `$$$$`;
    io:println(temp4); // @output $$$$
    string temp5 = string `$v1$$v2$`;
    io:println(temp5); // @output $v1$$v2$
    string temp6 = string `{}`;
    io:println(temp6); // @output {}
}

Test-Case: error
Description: Test every character that is not part of an interpolation is interpreted as a literal character.
Fail-Issue: ballerina-platform/ballerina-lang#35515
Labels: string, string-template-expr

function errorFunction() {
    string _ = string `${`;
}

function f1() {
    string name = "Ballerina";
    string _ = string `${name}`;
}

function f2() {
    string _ = string `${`;
}


Test-Case: error
Description: Test every character that is not part of an interpolation is interpreted as a literal character.
Fail-Issue: ballerina-platform/ballerina-lang#36974
Labels: string, string-template-expr

function errorFunction() {
    string _ = string `${`}`; // @error backtick as a expression
}

Test-Case: output
Description: Test string template expression is evaluated by evaluating the expression in each interpolation in the order in
which they occur.
Labels: boolean, function-call-expr, int, string, string-template-expr

function init() {
    string a1 = "a1";
    string b1 = "b1";
    string temp1 = string `${a1} ${b1}`;
    io:println(temp1); // @output a1 b1
    int a2 = 12;
    string temp2 = string `${a2} ${b1 + a1}`;
    io:println(temp2); // @output 12 b1a1
    int a3 = 13;
    int b2 = 15;
    string temp3 = string `$ $ $ ${a2 + a3} $ $ $ ${b2 + a2}`;
    io:println(temp3); // @output $ $ $ 25 $ $ $ 27
    boolean a4 = true;
    string temp4 = string `$ $ $ ${a2 + a3} $ $ $ ${a4}`;
    io:println(temp4); // @output $ $ $ 25 $ $ $ true
    string temp5 = string `$ $ $ ${f1()} $ $ $ ${f2()} $ $ $ ${f3()}`;
    io:println(temp5); // @output $ $ $ 10 $ $ $ 10 $ $ $ 10
    string temp6 = string `${"c"}${"s"}`;
    io:println(temp6); // @output cs
}

function f1() returns int {
    return 10;
}

function f2() returns int {
    return 10;
}

function f3() returns int {
    return 10;
}

Test-Case: output
Description: Test literal ` included in string template.
Labels: string, string-template-expr

function init() {
    string temp1 = string `${"`"}`;
    io:println(temp1); // @output `
}

Test-Case: error
Description: Test interpolation without expression
Labels: string, string-template-expr

function errorFunction() {
    string _ = string `${}`; // @error missing expression
}

Test-Case: output
Description: Test nested string template expressions.
Labels: string, string-template-expr

function init() {
    string a1 = "abc";
    string temp1 = string `${string `$ $ ${a1} $ $`}`;
    io:println(temp1); // @output $ $ abc $ $
    string a2 = "xyz";
    string temp2 = string `${string `$ $ ${string `$ $ ${a1} ${a2} $ $`} $ $`}`;
    io:println(temp2); // @output $ $ $ $ abc xyz $ $ $ $
}

Test-Case: output
Description: Test string template expressions with string single escapes.
Labels: string, string-template-expr

function init() {
    string a1 = "\t";
    string temp1 = string `$${a1}$`;
    io:println(temp1); // @output $ $
    string a2 = "\n";
    string temp2 = string `$${a2}$`;
    io:println(temp2); // @output $
    string a3 = "\r";
    string temp3 = string `$${a3}$`;
    io:println(temp3); // @output $
}
